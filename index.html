<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Hypercube with Generalized Rotation - v1.5</title>
    <style>
        body { margin: 0; background-color: white; display: flex; flex-direction: column; align-items: center; }
        .canvas-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; }
        .canvas-wrapper { text-align: center; }
        canvas { background-color: white; }
        #controls { margin-top: 20px; }
        button { margin: 5px; padding: 10px; }
        #instructions, #shape-name, #version { font-family: Arial, sans-serif; color: black; margin-top: 10px; text-align: center; }
    </style>
</head>
<body>
    <div id="instructions">
        <p><strong>Rotation and Controls</strong></p>
    </div>

    <div class="canvas-container">
        <div class="canvas-wrapper">
            <canvas id="canvas1" width="300" height="300"></canvas>
            <p>Projection Mode 1: (U, Y, Z, X)</p>
        </div>
        <div class="canvas-wrapper">
            <canvas id="canvas2" width="300" height="300"></canvas>
            <p>Projection Mode 2: (X, U, Z, Y)</p>
        </div>
        <div class="canvas-wrapper">
            <canvas id="canvas3" width="300" height="300"></canvas>
            <p>Projection Mode 3: (X, Y, U, Z)</p>
        </div>
        <div class="canvas-wrapper">
            <canvas id="canvas4" width="300" height="300"></canvas>
            <p>Projection Mode 4: (X, Y, Z, U)</p>
        </div>
    </div>

    <div id="controls">
        <button id="switchShape">Switch Shape</button>
        <button id="resetPosition">Reset Position</button>
        <button id="zoomIn">Zoom In</button>
        <button id="zoomOut">Zoom Out</button>
    </div>

    <div id="shape-name"></div>
    <div id="version">Code Version: v1.5</div>

    <script type="module">
        import { hypercubeVertices, hypercubeEdges } from './shapes/hypercubeData.js';
        import { cubeVertices, cubeEdges } from './shapes/cubeData.js';
        import { tetrahedronVertices, tetrahedronEdges } from './shapes/tetrahedronData.js';
        import { tetrahedron4DVertices, tetrahedron4DEdges } from './shapes/tetrahedron4DData.js';

        const canvases = [
            { canvas: document.getElementById('canvas1'), rotationAxes: [3, 1, 2, 0] }, // (U, Y, Z, X)
            { canvas: document.getElementById('canvas2'), rotationAxes: [0, 3, 2, 1] }, // (X, U, Z, Y)
            { canvas: document.getElementById('canvas3'), rotationAxes: [0, 1, 3, 2] }, // (X, Y, U, Z)
            { canvas: document.getElementById('canvas4'), rotationAxes: [0, 1, 2, 3] }  // (X, Y, Z, U)
        ];

        const shapes = [
            { name: 'Hypercube', universalVertices4D: hypercubeVertices.map(v => [...v]), edges: hypercubeEdges, initialVertices4D: hypercubeVertices.map(v => [...v]) },
            { name: 'Cube', universalVertices4D: cubeVertices.map(v => [...v]), edges: cubeEdges, initialVertices4D: cubeVertices.map(v => [...v]) },
            { name: 'Tetrahedron', universalVertices4D: tetrahedronVertices.map(v => [...v]), edges: tetrahedronEdges, initialVertices4D: tetrahedronVertices.map(v => [...v]) },
            { name: '4D Tetrahedron', universalVertices4D: tetrahedron4DVertices.map(v => [...v]), edges: tetrahedron4DEdges, initialVertices4D: tetrahedron4DVertices.map(v => [...v]) }
        ];

        let currentShapeIndex = 0;
        let currentShape = shapes[currentShapeIndex];
        let scale = 80;
        const k = 255;
        const rotationState = { axis1_axis3: 0, axis2_axis3: 0 };
        let lastX, lastY, isDragging = false;

        function displayShapeName() {
            document.getElementById('shape-name').textContent = `Current Shape: ${currentShape.name}`;
        }
        displayShapeName();

        // 2Dに投影
        function project4DTo2D(vertex4D, offsetX, offsetY) {
            const [x, y, z, u] = vertex4D;
            const perspective = 3 - z;
            const px = (x / perspective) * scale + offsetX;
            const py = (y / perspective) * scale + offsetY;
            const color = u < 0 ? `rgb(${k * Math.abs(u)}, 0, 0)` : `rgb(0, 0, ${k * Math.abs(u)})`;
            return { x: px, y: py, color };
        }

        function drawVerticesAndEdges(ctx, rotationAxes) {
            const offsetX = ctx.canvas.width / 2;
            const offsetY = ctx.canvas.height / 2;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            const rotatedVertices = currentShape.universalVertices4D.map(vertex4D => {
                let projectedVertex = rotationAxes.map(axis => vertex4D[axis]);

                // 回転を適用
                if (rotationState.axis1_axis3) projectedVertex = rotate4D(projectedVertex, rotationState.axis1_axis3 * 0.02, 0, 2);
                if (rotationState.axis2_axis3) projectedVertex = rotate4D(projectedVertex, rotationState.axis2_axis3 * 0.02, 1, 2);

                return projectedVertex;
            });

            // 辺の描画
            currentShape.edges.forEach(([startIdx, endIdx]) => {
                const startVertex = rotatedVertices[startIdx];
                const endVertex = rotatedVertices[endIdx];
                for (let i = 0; i <= 50; i++) {
                    const t = i / 50;
                    const interpolatedVertex = [
                        startVertex[0] * (1 - t) + endVertex[0] * t,
                        startVertex[1] * (1 - t) + endVertex[1] * t,
                        startVertex[2] * (1 - t) + endVertex[2] * t,
                        startVertex[3] * (1 - t) + endVertex[3] * t,
                    ];
                    const { x, y, color } = project4DTo2D(interpolatedVertex, offsetX, offsetY);
                    ctx.beginPath();
                    ctx.arc(x, y, 1, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            });

            // 頂点の描画
            rotatedVertices.forEach(vertex => {
                const { x, y, color } = project4DTo2D(vertex, offsetX, offsetY);
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            });
        }

        function updateAndDraw() {
            canvases.forEach(({ canvas, rotationAxes }) => {
                const ctx = canvas.getContext('2d');
                drawVerticesAndEdges(ctx, rotationAxes);
            });
        }

        function resetToInitialPosition() {
            currentShape.universalVertices4D = currentShape.initialVertices4D.map(v => [...v]); // 初期位置をコピーして復元
            updateAndDraw();
        }

        // 各キャンバスにドラッグ操作での回転軸設定
        canvases.forEach(({ canvas }) => {
            canvas.addEventListener('mousedown', (e) => { 
                isDragging = true; 
                lastX = e.clientX; 
                lastY = e.clientY; 
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    rotationState.axis1_axis3 += deltaX * 0.001;
                    rotationState.axis2_axis3 += deltaY * 0.001;
                }
            });
            canvas.addEventListener('mouseup', () => { isDragging = false; });
            canvas.addEventListener('mouseleave', () => { isDragging = false; });
            canvas.addEventListener('touchstart', (e) => { 
                isDragging = true; 
                lastX = e.touches[0].clientX; 
                lastY = e.touches[0].clientY; 
            });
            canvas.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const deltaX = e.touches[0].clientX - lastX;
                    const deltaY = e.touches[0].clientY - lastY;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    rotationState.axis1_axis3 += deltaX * 0.001;
                    rotationState.axis2_axis3 += deltaY * 0.001;
                }
            });
            canvas.addEventListener('touchend', () => { isDragging = false; });
        });

        // ボタン操作
        document.getElementById('switchShape').addEventListener('click', () => {
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            currentShape = shapes[currentShapeIndex];
            displayShapeName();
            resetToInitialPosition();
        });

        document.getElementById('resetPosition').addEventListener('click', resetToInitialPosition);

        document.getElementById('zoomIn').addEventListener('click', () => {
            scale += 10;
            updateAndDraw();
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            scale -= 10;
            updateAndDraw();
        });

        // 4D回転処理
        function rotate4D(vertex4D, angle, axis1, axis2) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);

            let rotatedVertex = [...vertex4D];
            rotatedVertex[axis1] = cos * vertex4D[axis1] - sin * vertex4D[axis2];
            rotatedVertex[axis2] = sin * vertex4D[axis1] + cos * vertex4D[axis2];
            
            return rotatedVertex;
        }

        // アニメーションの簡略化: 各キャンバスに対応する回転と描画を直接呼び出す
        function animate() {
            updateAndDraw();
            requestAnimationFrame(animate);
        }

        // アニメーション開始
        animate();
    </script>
</body>
</html>
